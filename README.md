# Индивидуальный проект Пан Артёма - Online Judge (gateway)

В рамках проекта разрабатывался сервис-гейтвей, который в будущем мог бы стать
частью системы онлайн проверки решений по типу [codeforces](https://codeforces.com).

Задеплоенная версия доступна на [89.111.154.137:8080/docs/](http://89.111.154.137:8080/docs/) 
(нужен именно префикс `/docs/`, а не `/docs` для правильного маршрутизирования
последующих запросов в браузере). Юзернейм - `admin`, пароль - `admin`.

## Функциональность

- [Авторизация по юзернейму и паролю с двумя ролями: админ и участник](http://89.111.154.137:8080/docs/#/default/post_login)

  Выданный JWT токен нужно далее вставить в хэдер `Authorization`
  (доступен в swagger'е в `Authorize`).

- [Админ может зарегистрировать участника (юзернейм, пароль, почта)](http://89.111.154.137:8080/docs/#/default/post_admin_participant)
- [Админ может создать проблему (текстовое поле: описание задачи)](http://89.111.154.137:8080/docs/#/default/post_admin_problem)
- [Участник может посмотреть список id проблем](http://89.111.154.137:8080/docs/#/default/get_problem)
- [Участник узнать описание проблемы по ее id](http://89.111.154.137:8080/docs/#/default/get_problem__problemId_)
- [Участник может послать решение проблемы (текстовое поле: решение)](http://89.111.154.137:8080/docs/#/default/post_problem__problemId_)
- Решение проблемы при создании имеет статус Обрабатывается
- Решение из статуса Обрабатывается может перейти в статус 
  Верно или Неверно
- [Участник может отслеживать статус решения по его id, выданному при создании](http://89.111.154.137:8080/docs/#/default/get_submission__submissionId_)
- Админ может просматривать решения всех участников
- Для других участников решение по этому id должно быть недоступно: 404 NotFound
- [Админ и участник могут узнать email любого участника по его юзернейму](http://89.111.154.137:8080/docs/#/default/get_email__username_)

## Архитектура системы

Для хранения данных используется `Postgres`.

Для UI документации API ([/docs/](http://89.111.154.137:8080:8080/docs/)) используется `swagger-ui`,
запускаемый как отдельный сервис. Это дает преимущества микросервисной архитектуры:
поправить документацию можно без перезапуска основного приложения.

Приложение разделено на два микросервиса: `gateway`, отвечающий за информацию о пользователях и 
описание проблем, и `core`, отвечающий за обработку решения проблемы. В рамках этого проекта
реализован только `gateway`, `core` представляет собой заглушку, которая имитирует долгую обработку
решения (`Temporal[F].sleep(30.seconds)`) и считает правильным только ответ `4` (вне зависимости
от проблемы).

Для общения двух сервисов используется очередь сообщений. Так как объем сообщений
(решения и результат) достаточно небольшой и цикл жизни сообщений не требует ничего
более сложного, чем produce-consume, в качестве брокера был выбран `RabbitMQ`, а не `Apache Kafka`.


Используется политика отправки сообщений `at least once`. 
Процесс обработки решения выстроен следующим образом:

1. Создаем в базе данных драфт решения, заодно проверив, что `problemId` существует

  Напомню, что проблему в нашей системе удалить нельзя, 
  что упрощает получение некоторых гарантий консистентности данных.

2. Отправляем решение в очередь (и получаем [подтверждение](https://www.rabbitmq.com/docs/reliability#confirms))
3. "Публикуем" драфт по id (отдельная таблица), полученному на 1-ом шаге 
и возвращаем его участнику
4. Читаем из очереди результат проверки
5. Обновляем статус в базе данных
6. Уведомляем очередь, что сообщение обработано ([acknowledgement](https://www.rabbitmq.com/docs/reliability#confirms))

Если на 2-ом шаге решение было записано в очередь, но мы не получили подтверждение этого
или у нас упал дата-центр и мы не дошли до 3-его шага,
база данных не будет знать об этом решении и, когда мы получим результат проверки, мы его
проигнорируем (написав warning в логи).

Если мы дошли до 6-го шага, но не смогли уведомить очередь (упал дата-центр или
потеряли соединение с очередью), то брокер не будет считать наше сообщения обработанным,
и мы перейдем к 5-ому шагу еще раз: он идемпотентен, поэтому ничего страшного не произойдет.

Все сервисы запускаются [в Docker'е](docker-compose.yaml).

## Локальный запуск

### С упаковкой приложения (рекомендуется)

Для упаковки приложения используется [sbt-native-packager](https://www.scala-sbt.org/sbt-native-packager/). 
В `sbt-shell` выполните

```
  Docker / publishLocal
```

Это сбилдит локально образы `jejutic/onlinejudge-gateway` и `jejutic/onlinejudge-core-stub`,
которые используются в [docker-compose файле](docker-compose.yaml):

```shell
  docker compose up
```

### Без упаковки приложения

Запустите

```shell
  docker compose -f docker-compose-local.yaml up
```

Это поднимет `Postgres`, `swagger-ui` и `RabbitMQ` на 
`localhost:5432`, `localhost:8081` и `localhost:5672` 
([веб-интерфейс на 15672-ом порту](http://localhost:15672)) соответственно.

Далее запустите само приложение через `sbt shell`:

```
  gateway / run
```

Если хотите также запустить `core`-заглушку, можно упаковать ее в jar и запустить
отдельным процессом.

## Использованные библиотеки, заслуживающие внимания

- [cats effect 3](https://typelevel.org/cats-effect/)
- [refined](https://github.com/fthomas/refined)

   Использовалась для ограничения полей добавления участника в связке с `circe`.

- [http4s](https://http4s.org/)

  Была выбрана из-за удобного DSL.

- [pureconfig](https://pureconfig.github.io/)
- [doobie](https://github.com/tpolecat/doobie)
- [flyway](https://github.com/flyway/flyway)
- [fs2-rabbit](https://fs2-rabbit.profunktor.dev/)
